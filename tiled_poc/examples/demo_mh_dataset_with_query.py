# /// script
# requires-python = ">=3.11"
# dependencies = [
#     "marimo",
#     "tiled[server]",
#     "pandas",
#     "h5py",
#     "numpy",
#     "ruamel.yaml",
#     "matplotlib",
#     "torch",
# ]
# ///

import marimo

__generated_with = "0.19.2"
app = marimo.App(width="medium")


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    # VDP Query-Based M(H) Dataset Demo

    ## The Science Challenge: Inverse Problems in Quantum Magnetism

    Determining the **spin Hamiltonian** of a quantum magnetic material traditionally requires months to years
    of manual trial-and-error: measure data, guess parameters, simulate, compare, adjust, repeat.
    The **MAIQMag project** aims for a **10× speedup** using machine learning trained on synthetic data.

    This catalog contains **10,000 Heisenberg spin systems** generated by [Sunny.jl](https://github.com/SunnySuite/Sunny.jl), each defined by:

    | Parameter | Physical Meaning | Sign Convention |
    |-----------|------------------|-----------------|
    | **Ja, Jb, Jc** | Exchange coupling along crystal axes | J > 0: ferromagnetic (parallel spins) |
    | **Dc** | Single-ion anisotropy | Dc < 0: easy-axis (spins prefer z) |

    ## This Demo

    **Query:** Strong ferromagnetic (Ja > 0.5 meV) + easy-axis anisotropy (Dc < -0.5 meV)

    This selects materials where neighboring spins strongly prefer parallel alignment,
    and the crystal field favors magnetization along the z-axis — a classic "Ising-like" ferromagnet.

    | Mode | Pattern | Best For |
    |------|---------|----------|
    | **Mode A (Expert)** | `query_manifest()` → direct HDF5 | ML pipelines, bulk loading |
    | **Mode B (Visualizer)** | `h["mh_powder_30T"][:]` | Interactive exploration, remote |

    **Prerequisites:** Start the Tiled server:
    ```bash
    cd $PROJ_VDP/tiled_poc
    uv run --with 'tiled[server]' tiled serve config config.yml --api-key secret
    ```
    """)
    return


@app.cell
def _():
    import marimo as mo
    import numpy as np
    import time
    import sys
    from pathlib import Path

    # Add tiled_poc directory to path for broker package imports
    sys.path.insert(0, str(Path(__file__).parent.parent))

    # Use config module for configuration
    from broker.config import get_tiled_url, get_api_key

    TILED_URL = get_tiled_url()
    API_KEY = get_api_key()

    # Demo configuration constants
    N_CURVES_VISUALIZE = 10    # Number of curves to show in plots
    BATCH_SIZE = 4             # PyTorch DataLoader batch size
    HMAX_T = 30                # Default max field (Tesla)
    AXIS = "powder"            # Default axis for M(H) curves

    return API_KEY, AXIS, BATCH_SIZE, HMAX_T, N_CURVES_VISUALIZE, TILED_URL, mo, np, time


@app.cell
def _(API_KEY, TILED_URL, mo):
    # Connect to Tiled server
    from tiled.client import from_uri
    from tiled.queries import Key

    client = from_uri(TILED_URL, api_key=API_KEY)

    # Apply physics-based query: strong ferromagnetic + easy-axis anisotropy
    subset = client.search(Key("Ja_meV") > 0.5).search(Key("Dc_meV") < -0.5)

    mo.md(f"""**Connected to VDP server at `{TILED_URL}`.**

    - Full catalog: **{len(client)}** entities
    - After query (`Ja > 0.5`, `Dc < -0.5`): **{len(subset)}** entities

    ### What This Query Selects

    **Ja > 0.5 meV** (strong ferromagnetic):
    - Exchange coupling J > 0 means neighboring spins prefer parallel alignment
    - Larger |J| means stronger magnetic ordering, higher Curie temperature
    - These materials will saturate more readily in applied field

    **Dc < -0.5 meV** (easy-axis anisotropy):
    - Single-ion anisotropy D < 0 creates an energy barrier for spins to rotate away from z-axis
    - This gives the magnetization a preferred direction (uniaxial magnet)
    - Results in more "Ising-like" behavior with sharp magnetization steps
    """)
    return (subset,)


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Browse Hierarchical Structure

    Each entity is a **container** with:
    - **Metadata**: Physics parameters (Ja, Jb, Jc, Dc) + artifact paths
    - **Children**: Computed observables accessible via Tiled adapters

    ### Understanding the Parameters

    | Parameter | What It Controls | Physical Effect |
    |-----------|------------------|-----------------|
    | `Ja_meV`, `Jb_meV`, `Jc_meV` | Spin-spin coupling along a, b, c axes | Sign determines FM (+) vs AFM (-) order |
    | `Dc_meV` | On-site anisotropy energy | Selects easy-axis (−) or easy-plane (+) |
    | `spin_s` | Spin quantum number (S=5/2 for Fe²⁺) | Sets saturation moment Msat = g·S |
    | `g_factor` | Landé g-factor (≈2 for spin-only) | Relates spin to magnetic moment |
    """)
    return


@app.cell
def _(mo, subset):
    # Get first entity container from the filtered subset
    ent_keys = list(subset.keys())[:5]
    ent_key = ent_keys[0] if ent_keys else None

    if ent_key:
        h = subset[ent_key]
        children = list(h.keys())

        # Physics parameters
        physics_keys = ["Ja_meV", "Jb_meV", "Jc_meV", "Dc_meV", "spin_s", "g_factor"]
        physics_rows = "\n".join([
            f"| {k} | {h.metadata.get(k, 'N/A'):.4f} |"
            if isinstance(h.metadata.get(k), float) else f"| {k} | {h.metadata.get(k, 'N/A')} |"
            for k in physics_keys
        ])

        # Path keys (for Mode A)
        path_keys = [k for k in h.metadata.keys() if k.startswith("path_")]

        # Children table
        child_rows = "\n".join([
            f"| {ck} | `{h[ck].shape}` | `{h[ck].dtype}` |"
            for ck in children[:6]
        ])

        _output = mo.md(f"""
    ### Container: `{ent_key}`

    **Physics Parameters (Metadata):**

    | Parameter | Value |
    |-----------|-------|
    {physics_rows}

    **Artifact Paths (Mode A):** {len(path_keys)} paths available in metadata

    **Children (Mode B):**

    | Key | Shape | Dtype |
    |-----|-------|-------|
    {child_rows}
    {"| ... | | |" if len(children) > 6 else ""}
        """)
    else:
        h = None
        children = []
        physics_keys = []
        path_keys = []
        _output = mo.md("No entities found. Run `register_catalog.py` first.")

    _output
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Mode A: Expert Path-Based Access

    **Best for:** ML pipelines, bulk loading, maximum performance

    ```python
    from query_manifest import build_mh_dataset

    # Query Tiled -> get paths -> load directly from HDF5
    X, h_grid, Theta, manifest = build_mh_dataset(subset, axis="powder", Hmax_T=30)
    ```

    **Tiled provides:** Queryable manifest with HDF5 paths
    **You do:** Direct HDF5 loading (no HTTP overhead)
    """)
    return


@app.cell
def _(AXIS, HMAX_T, mo, subset, time):
    from broker.query_manifest import query_manifest, load_from_manifest, build_mh_dataset

    # Step 1: Query manifest from the filtered subset
    _t0 = time.perf_counter()
    manifest = query_manifest(subset, axis=AXIS, Hmax_T=HMAX_T)
    query_time = (time.perf_counter() - _t0) * 1000

    # Step 2: Load from HDF5
    _t1 = time.perf_counter()
    X_a, Theta_a = load_from_manifest(manifest)
    load_time = (time.perf_counter() - _t1) * 1000

    total_time_a = query_time + load_time

    mo.md(f"""
    ### Mode A Results

    | Step | Time |
    |------|------|
    | Query manifest | {query_time:.1f} ms |
    | Load from HDF5 | {load_time:.1f} ms |
    | **Total** | **{total_time_a:.1f} ms** |

    **Loaded:** {len(X_a)} curves, shape `{X_a.shape}`
    """)
    return Theta_a, X_a, manifest, total_time_a


@app.cell
def _(manifest):
    manifest
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Mode B: Tiled Adapter Access

    **Best for:** Interactive exploration, visualization, remote access

    ```python
    # Access arrays directly via Tiled
    h = subset["H_636ce3e4"]
    data = h["mh_powder_30T"][:]     # Full array
    slice = h["ins_12meV"][100:200, 50:150]  # Partial read
    ```

    **Tiled provides:** Chunked array access via HTTP
    **You get:** Remote access, slicing, no file management
    """)
    return


@app.cell
def _(AXIS, HMAX_T, mo, np, subset, time):
    # Mode B: Load via Tiled adapters
    def build_mh_dataset_mode_b(tiled_client, *, axis="powder", Hmax_T=30, clamp_H0=True):
        """Build M(H) dataset using Tiled adapters (Mode B)."""
        artifact_key = f"mh_{axis}_{int(Hmax_T)}T"

        X_list = []
        Theta_list = []

        # Use .items() to iterate all items (not paginated like .keys())
        for ent_key, h in tiled_client.items():
            if artifact_key not in h.keys():
                continue

            params = h.metadata
            spin_s = params.get("spin_s", 2.5)
            g_factor = params.get("g_factor", 2.0)
            Msat = g_factor * spin_s

            # Load via Tiled adapter (HTTP)
            M = h[artifact_key][:]

            if clamp_H0:
                M = M.copy()
                M[0] = 0.0

            X_list.append(M / Msat)
            Theta_list.append([
                params["Ja_meV"], params["Jb_meV"],
                params["Jc_meV"], params["Dc_meV"],
                spin_s, g_factor,
            ])

        if not X_list:
            raise ValueError(f"No curves found for axis={axis}, Hmax_T={Hmax_T}")

        X = np.stack(X_list, dtype=np.float32)
        Theta = np.array(Theta_list, dtype=np.float32)
        h_grid = np.linspace(0, 1, X.shape[1], dtype=np.float32)

        return X, h_grid, Theta

    _t0 = time.perf_counter()
    X_b, h_grid, Theta_b = build_mh_dataset_mode_b(subset, axis=AXIS, Hmax_T=HMAX_T)
    total_time_b = (time.perf_counter() - _t0) * 1000

    mo.md(f"""
    ### Mode B Results

    | Metric | Value |
    |--------|-------|
    | **Total time** | **{total_time_b:.1f} ms** |
    | Curves loaded | {len(X_b)} |
    | Shape | `{X_b.shape}` |
    """)
    return (total_time_b,)


@app.cell(hide_code=True)
def _(mo, total_time_a, total_time_b):
    ratio = total_time_a / total_time_b if total_time_b > 0 else 0

    mo.md(f"""
    ## Performance Comparison

    | Mode | Time | Use Case |
    |------|------|----------|
    | **Mode A (Expert)** | {total_time_a:.1f} ms | ML training, bulk loading |
    | **Mode B (Visualizer)** | {total_time_b:.1f} ms | Interactive exploration |

    **Ratio:** Mode A / Mode B = {ratio:.2f}x
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Physics of M(H) Curves

    ### What the Curves Tell Us

    The M(H) curve shape encodes information about the underlying Hamiltonian:

    **Saturation behavior:**
    - **Easy saturation** (rapid rise): Strong ferromagnetic coupling (large positive J)
    - **Hard saturation** (gradual rise): Competing interactions or antiferromagnetic coupling
    - **Saturation field**: Related to anisotropy and exchange strength

    **Curve shape signatures:**
    - **Concave-up near origin**: Typical ferromagnet, spins already partially aligned
    - **S-shaped (inflection point)**: Spin reorientation or metamagnetic transition
    - **Linear region**: Paramagnet-like susceptibility regime

    **Effect of anisotropy (Dc):**
    - **Easy-axis (Dc < 0)**: Sharper magnetization steps along z, more isotropic powder average
    - **Easy-plane (Dc > 0)**: Different response along z vs. in-plane directions

    ### The Inverse Problem

    **Goal:** Given an experimental M(H) curve, determine (Ja, Jb, Jc, Dc)

    **Challenge:** Multiple parameter combinations can produce similar curves (ill-posed problem)

    **Solution:** Use ML to learn the inverse mapping, trained on this synthetic database
    where ground truth parameters are known exactly.
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## PyTorch DataLoader Integration

    ### Training the Inverse Solver

    The VDP catalog enables training neural networks to solve the inverse problem:
    **Input:** M(H) curve (200 points) → **Output:** Hamiltonian parameters (Ja, Jb, Jc, Dc)

    **Why this matters:**
    - Traditional fitting: months of manual parameter tuning by experts
    - ML approach: train once, infer in milliseconds with uncertainty quantification

    **Data flow:**
    ```python
    dataset = VDPDataset(subset, artifact_key="mh_powder_30T")
    dataloader = DataLoader(dataset, batch_size=4, shuffle=True)

    for batch_data, batch_params in dataloader:
        # batch_data: (4, 200) normalized M(H) curves
        # batch_params: (4, 4) Hamiltonian parameters [Ja, Jb, Jc, Dc]
        predictions = model(batch_data)
        loss = criterion(predictions, batch_params)
    ```

    **Mode A vs Mode B for ML:**
    - **Mode A (Expert):** Bulk load entire training set via HDF5 → fast epoch iteration
    - **Mode B (Visualizer):** On-demand loading → useful for debugging, smaller experiments
    """)
    return


@app.cell
def _(np):
    import torch
    from torch.utils.data import Dataset, DataLoader

    class VDPDataset(Dataset):
        """PyTorch Dataset using VDP hierarchical catalog."""

        def __init__(self, tiled_client, artifact_key="mh_powder_30T"):
            self.client = tiled_client
            self.artifact_key = artifact_key
            # Cache keys that have the requested artifact
            self.ent_keys = [
                k for k, h in tiled_client.items()
                if artifact_key in h.keys()
            ]

        def __len__(self):
            return len(self.ent_keys)

        def __getitem__(self, idx):
            ent_key = self.ent_keys[idx]
            h = self.client[ent_key]

            # Load via Tiled adapter
            data = h[self.artifact_key][:]

            # Physics params from container metadata
            params = h.metadata
            param_tensor = torch.tensor([
                params.get("Ja_meV", 0.0) or 0.0,
                params.get("Jb_meV", 0.0) or 0.0,
                params.get("Jc_meV", 0.0) or 0.0,
                params.get("Dc_meV", 0.0) or 0.0,
            ], dtype=torch.float32)

            data_tensor = torch.from_numpy(data.astype(np.float32))
            return data_tensor, param_tensor
    return DataLoader, VDPDataset


@app.cell
def _(AXIS, BATCH_SIZE, DataLoader, HMAX_T, VDPDataset, mo, subset, time):
    # Create dataset and dataloader from the filtered subset
    artifact_key = f"mh_{AXIS}_{HMAX_T}T"
    dataset = VDPDataset(subset, artifact_key=artifact_key)
    dataloader = DataLoader(dataset, batch_size=BATCH_SIZE, shuffle=True)

    # Load first batch
    start = time.perf_counter()
    batch_data, batch_params = next(iter(dataloader))
    load_time_dl = (time.perf_counter() - start) * 1000

    mo.md(f"""
    ### DataLoader Demo

    **Dataset size:** {len(dataset)} entities with `{artifact_key}`
    **Batch size:** {BATCH_SIZE}

    **First batch loaded in {load_time_dl:.1f} ms:**
    - Data shape: `{tuple(batch_data.shape)}` (batch, 200 field points)
    - Params shape: `{tuple(batch_params.shape)}` (batch, 4 params: Ja, Jb, Jc, Dc)

    **Sample parameters (Ja, Jb, Jc, Dc):**
    - Sample 0: `[{batch_params[0, 0]:.3f}, {batch_params[0, 1]:.3f}, {batch_params[0, 2]:.3f}, {batch_params[0, 3]:.3f}]`
    - Sample 1: `[{batch_params[1, 0]:.3f}, {batch_params[1, 1]:.3f}, {batch_params[1, 2]:.3f}, {batch_params[1, 3]:.3f}]`
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Visualize M(H) Curves

    ### What to Look For

    **Left plot (M(H) curves colored by Ja):**
    - All curves from our query have Ja > 0.5 (ferromagnetic) and Dc < -0.5 (easy-axis)
    - Higher Ja (red) → faster saturation (spins align more easily)
    - Similar shapes expected since we filtered for similar physics

    **Right plot (Parameter space):**
    - Shows the (Ja, Dc) region we queried
    - Color encodes Jb (exchange along b-axis)
    - This is the "training data coverage" for our physics-filtered ML model
    """)
    return


@app.cell
def _(N_CURVES_VISUALIZE, Theta_a, X_a, mo, np):
    import matplotlib.pyplot as plt

    fig, axes = plt.subplots(1, 2, figsize=(12, 4))

    # Plot 1: Sample curves colored by Ja
    ax1 = axes[0]
    n_samples = min(N_CURVES_VISUALIZE, len(X_a))
    h_grid_plot = np.linspace(0, 1, X_a.shape[1])
    colors = plt.cm.coolwarm(np.linspace(0, 1, n_samples))

    for i in range(n_samples):
        ax1.plot(h_grid_plot, X_a[i], color=colors[i], alpha=0.8,
                 label=f"Ja={Theta_a[i, 0]:.2f}")
    ax1.set_xlabel("Reduced field h = H/Hmax")
    ax1.set_ylabel("Normalized magnetization m = M/(g*s)")
    ax1.set_title("M(H) Curves (colored by Ja_meV)")
    ax1.legend(fontsize=8, loc="lower right")
    ax1.grid(True, alpha=0.3)

    # Plot 2: Parameter distribution
    ax2 = axes[1]
    sc = ax2.scatter(Theta_a[:, 0], Theta_a[:, 3], c=Theta_a[:, 1], cmap="viridis", alpha=0.7)
    ax2.set_xlabel("Ja_meV")
    ax2.set_ylabel("Dc_meV")
    ax2.set_title("Parameter Space (color = Jb_meV)")
    ax2.grid(True, alpha=0.3)
    plt.colorbar(sc, ax=ax2, label="Jb_meV")

    plt.tight_layout()
    mo.md("### M(H) Visualization")
    return (fig,)


@app.cell
def _(fig):
    fig
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Summary

    ### The Scientific Workflow

    ```
    ┌─────────────────┐      ┌─────────────────┐      ┌─────────────────┐
    │  Sunny.jl       │ ───► │  VDP Catalog    │ ───► │  ML Training    │
    │  (simulation)   │      │  (Tiled)        │      │  (PyTorch)      │
    └─────────────────┘      └─────────────────┘      └─────────────────┘
     10K entities             Query by physics         Inverse solver
     110K artifacts           Sub-ms metadata          M(H) → (Ja,Jb,Jc,Dc)
    ```

    ### What This Demo Shows

    1. **Physics-aware queries** - Select by exchange coupling (J) and anisotropy (D), not file paths
    2. **Server-side filtering** - Reduce 10K → relevant subset before data transfer
    3. **Two access modes** for different workflows:
       - **Mode A (Expert):** Bulk HDF5 for fast ML training
       - **Mode B (Visualizer):** Interactive exploration via HTTP

    ### Toward the Goal: 10× Faster Hamiltonian Determination

    ```python
    # Traditional: months of manual fitting
    # MAIQMag: train once, infer in milliseconds

    client = from_uri(TILED_URL, api_key=API_KEY)
    subset = client.search(Key("Ja_meV") > 0.5).search(Key("Dc_meV") < -0.5)
    X, h_grid, Theta, manifest = build_mh_dataset(subset, axis="powder", Hmax_T=30)

    # X: training inputs (M(H) curves)
    # Theta: training labels (Hamiltonian parameters)
    # Ready for PyTorch DataLoader
    ```

    For full physics context, see `docs/CONTEXT-SCIENCE.md`.
    """)
    return


if __name__ == "__main__":
    app.run()
